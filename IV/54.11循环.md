54.11循环

    
    public class Loop
    {
    public static void main(String[] args)
    {
    for (int i = 1; i <= 10; i++)
    {
    System.out.println(i);
    }
    }
    }
    public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
    stack=2, locals=2, args_size=1
    0: iconst_1
    1: istore_1
    2: iload_1
    3: bipush 10
    5: if_icmpgt 21
    8: getstatic #2 // Field java/⤦
    Ç lang/System.out:Ljava/io/PrintStream;
    11: iload_1
    12: invokevirtual #3 // Method java/io⤦
    Ç /PrintStream.println:(I)V
    15: iinc 1, 1
    18: goto 2
    21: return


icont_1加载1到栈定，istore_1存贮它到LVA的参数槽1，为什么没有零槽？因为main()函数只有一个参数，并且指向他的引用，在第0号槽中。

因此，i本地变量总是在1号参数槽。
指令在行偏移3和5，是i和10的比较。如果i大，执行流进入行偏移21，函数结束了，如果不是，println被调用。i重新加载在行偏移11，被println使用。
多说一句，我们调用pringln打印整型的数据类型，我们看到注释，“I，V”I的意思是整型，V的意思是返回void。

当println函数结束，i是步进到行偏移15，指令第一个操作数是参数槽1的值。第二个是数值1与本地变量相加。

goto指令就是跳转，它跳转到循环体的开始地址再行偏移2.

928
让我们进行更复杂的例子。

    public class Fibonacci
    {
    public static void main(String[] args)
    {
    int limit = 20, f = 0, g = 1;
    for (int i = 1; i <= limit; i++)
    {
    f = f + g;
    g = f - g;
    System.out.println(f);
    }
    }
    }
    public static void main(java.lang.String[]);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
    stack=2, locals=5, args_size=1
    0: bipush 20
    2: istore_1
    3: iconst_0
    4: istore_2
    5: iconst_1
    6: istore_3
    7: iconst_1
    8: istore 4
    10: iload 4
    12: iload_1
    13: if_icmpgt 37
    16: iload_2
    17: iload_3
    18: iadd
    19: istore_2
    20: iload_2
    21: iload_3
    22: isub
    23: istore_3
    24: getstatic #2 // Field java/⤦
    Ç lang/System.out:Ljava/io/PrintStream;
    27: iload_2
    28: invokevirtual #3 // Method java/io⤦
    Ç /PrintStream.println:(I)V
    31: iinc 4, 1
    34: goto 10
    37: return



929
LVA槽参数映射。
0-main（）的唯一参数。
1-限制，总是20.
2-f
3-g
4-i

我们可以看到java编译器在LVA参数槽分配变量，并且是相同的时序，就像在源代码中声明吧变量。
分立指令istore指令是用于访问参数槽0123，但是不大于4，因此，附加操作符号在行偏移8，使用槽参数作为操作数，类似于在行偏移10的iload。

但没什么疑问的是，分批其他的槽，为了限制变量总是20（因此他本质上就是一个常数），重载他的值很正常吗？

JVM JIT 编译器经常可以对其优化的很好。在代码中人工的干预其实是没有什么价值的。


